# Plan: 3-3 - Fix Plan Generator

## Objective
Implement FixPlanGenerator that creates executable FIX_PLAN.md files with FR2.1 targeted fix plans for incomplete implementations.

## Context
The FixPlanGenerator produces the final FIX_PLAN.md file that executors can run. It must:
- Follow PLAN.md format
- Include all analysis context
- **FR2.1:** Generate targeted fix plans (only missing features, not completed ones)
- Be directly executable with `reis execute-plan`

## Dependencies
- Plan 2-3 (DebugAnalyzer exists)
- Plan 3-1 (SolutionDesigner exists)

## Tasks

<task type="auto">
<name>Implement FixPlanGenerator with FR2.1 targeted fix plan generation</name>
<files>lib/utils/fix-plan-generator.js</files>
<action>
Create fix plan generator with FR2.1 support:

```javascript
import fs from 'fs';
import path from 'path';

/**
 * Fix Plan Generator - Creates executable FIX_PLAN.md files
 * FR2.1: Generates targeted fix plans for incomplete implementations
 */
export class FixPlanGenerator {
  constructor(analysis) {
    this.analysis = analysis;
  }

  /**
   * Generate complete FIX_PLAN.md
   */
  generate() {
    const parts = [
      this.generateHeader(),
      this.generateObjective(),
      this.generateContext(),
      this.generateDependencies(),
      this.generateWaves(),
      this.generateSuccessCriteria(),
      this.generateVerification(),
      this.generateNotes()
    ];

    return parts.join('\n\n---\n\n');
  }

  /**
   * Generate plan header
   */
  generateHeader() {
    const issueType = this.analysis.classification.type;
    const timestamp = new Date().toISOString();

    return `# Fix Plan: ${this.generateTitle()}

**Generated by:** reis_debugger  
**Date:** ${timestamp}  
**Issue Type:** ${issueType}  
**Original Plan:** ${this.getOriginalPlanPath()}`;
  }

  /**
   * Generate fix plan title
   */
  generateTitle() {
    const type = this.analysis.classification.type;

    if (type === 'incomplete-implementation') {
      const incompleteness = this.analysis.classification.incompleteness;
      const missing = incompleteness.missing || [];
      
      if (missing.length === 1) {
        return `Implement Missing Feature: ${missing[0]}`;
      } else {
        return `Complete ${missing.length} Missing Features`;
      }
    }

    return `Fix ${type.replace(/-/g, ' ')}`;
  }

  /**
   * Generate objective section
   */
  generateObjective() {
    let objective = '## Objective\n\n';

    if (this.analysis.classification.type === 'incomplete-implementation') {
      const incompleteness = this.analysis.classification.incompleteness;
      objective += `Complete the missing deliverables from ${this.getOriginalPlanPath()}.\n\n`;
      objective += `**Current Status:** ${incompleteness.completeness}% complete `;
      objective += `(${incompleteness.completed}/${incompleteness.total} tasks)\n\n`;
      objective += `**This fix implements ONLY the missing features. Completed features will NOT be touched.**`;
    } else {
      objective += this.analysis.recommendation.description || 'Fix the identified issue';
    }

    return objective;
  }

  /**
   * Generate context section with FR2.1 incompleteness details
   */
  generateContext() {
    let context = '## Context\n\n';
    context += '### Original Issue\n\n';
    context += `**Type:** ${this.analysis.classification.type}\n`;
    context += `**Severity:** ${this.analysis.classification.severity}\n`;
    context += `**Scope:** ${this.analysis.classification.scope}\n\n`;

    // FR2.1: Incomplete implementation context
    if (this.analysis.classification.type === 'incomplete-implementation') {
      const incompleteness = this.analysis.classification.incompleteness;
      
      context += '### Completeness Analysis\n\n';
      context += `- **Original Plan:** ${this.getOriginalPlanPath()}\n`;
      context += `- **Completion:** ${incompleteness.completeness}%\n\n`;

      if (incompleteness.completedTasks && incompleteness.completedTasks.length > 0) {
        context += '**Completed Successfully:**\n';
        incompleteness.completedTasks.forEach(task => {
          context += `- ${task} ✅\n`;
        });
        context += '\n';
      }

      context += '**Missing:**\n';
      (incompleteness.missing || []).forEach(task => {
        context += `- ${task} ❌\n`;
      });
      context += '\n';

      context += `**Root Cause:** ${this.analysis.rootCause.likelyCause}\n`;
      context += `**Confidence:** ${(this.analysis.rootCause.confidence * 100).toFixed(0)}%\n\n`;

      if (this.analysis.rootCause.evidence && this.analysis.rootCause.evidence.length > 0) {
        context += '**Evidence:**\n';
        this.analysis.rootCause.evidence.slice(0, 3).forEach(e => {
          context += `- ${e}\n`;
        });
        context += '\n';
      }
    }

    context += '### Why This Fix\n\n';
    context += this.generateRationale();

    context += '\n\n### Constraints\n\n';
    context += this.generateConstraints();

    return context;
  }

  /**
   * Generate rationale for fix approach
   */
  generateRationale() {
    if (this.analysis.classification.type === 'incomplete-implementation') {
      return 'This fix plan implements ONLY the missing features using targeted re-execution. ' +
             'Completed features remain untouched to avoid wasted effort and risk of regression.';
    }

    return this.analysis.recommendation.approach || 'Standard fix approach for identified issue.';
  }

  /**
   * Generate constraints
   */
  generateConstraints() {
    const constraints = [];

    if (this.analysis.classification.type === 'incomplete-implementation') {
      const completed = this.analysis.classification.incompleteness.completedTasks || [];
      
      if (completed.length > 0) {
        const taskNumbers = completed
          .map(t => t.match(/Task (\d+)/))
          .filter(m => m)
          .map(m => m[1])
          .join(', ');
        
        constraints.push(`**DO NOT** modify completed tasks (Tasks ${taskNumbers})`);
        constraints.push('**DO NOT** re-implement working features');
        constraints.push('**ONLY** add missing deliverables');
        constraints.push('Ensure integration with existing code');
      }
    }

    if (constraints.length === 0) {
      constraints.push('Follow project coding standards');
      constraints.push('Maintain backward compatibility');
    }

    return constraints.map(c => `- ${c}`).join('\n');
  }

  /**
   * Generate dependencies section
   */
  generateDependencies() {
    let deps = '## Dependencies\n\n';

    if (this.analysis.classification.type === 'incomplete-implementation') {
      const completed = this.analysis.classification.incompleteness.completedTasks || [];
      
      if (completed.length > 0) {
        deps += `- Completed tasks from original plan (${completed.length} tasks)\n`;
      }
      deps += `- Original plan file: ${this.getOriginalPlanPath()}\n`;
    } else {
      deps += '- None\n';
    }

    return deps;
  }

  /**
   * Generate wave(s) with tasks
   */
  generateWaves() {
    let waves = '';

    if (this.analysis.classification.type === 'incomplete-implementation') {
      waves += this.generateIncompleteImplementationWave();
    } else {
      waves += this.generateStandardFixWave();
    }

    return waves;
  }

  /**
   * FR2.1: Generate wave for incomplete implementation
   */
  generateIncompleteImplementationWave() {
    const incompleteness = this.analysis.classification.incompleteness;
    const missing = incompleteness.missing || [];
    
    let wave = '## Wave Fix-1: Implement Missing Features\n\n';
    wave += `**Size:** ${this.estimateWaveSize(missing.length)} (${this.estimateTime(missing.length)})\n`;
    wave += `**Risk:** LOW\n\n`;
    wave += '### Tasks\n\n';

    missing.forEach((task, index) => {
      wave += this.generateIncompleteTask(task, index + 1);
      wave += '\n';
    });

    return wave;
  }

  /**
   * FR2.1: Generate task for missing feature
   */
  generateIncompleteTask(taskDescription, taskNumber) {
    const taskName = taskDescription.replace(/^Task \d+:?\s*/i, '');
    
    let task = '<task type="auto">\n';
    task += `<name>Implement ${taskName}</name>\n`;
    task += `<files>${this.inferFiles(taskName)}</files>\n`;
    task += '<action>\n';
    task += `Implement the missing "${taskName}" from the original plan.\n\n`;
    task += '**Specific steps:**\n';
    task += this.generateImplementationSteps(taskName);
    task += '\n\n**Integration:**\n';
    task += '- Connect with existing completed features\n';
    task += '- Use established patterns from completed tasks\n';
    task += '- Follow project structure\n\n';
    task += '**What to avoid:**\n';
    task += '- Modifying completed task code\n';
    task += '- Duplicating existing functionality\n';
    task += '- Breaking existing tests\n\n';
    task += '**Why:**\n';
    task += '- Maintains stability of working features\n';
    task += '- Minimizes regression risk\n';
    task += '</action>\n';
    task += '<verify>\n';
    task += this.generateVerificationCommands(taskName);
    task += '</verify>\n';
    task += '<done>\n';
    task += this.generateAcceptanceCriteria(taskName);
    task += '</done>\n';
    task += '</task>\n';

    return task;
  }

  /**
   * Infer file paths from task description
   */
  inferFiles(taskName) {
    const files = [];
    const taskLower = taskName.toLowerCase();

    if (taskLower.includes('endpoint') || taskLower.includes('route') || taskLower.includes('api')) {
      files.push('src/app/api/[feature]/route.ts');
    }
    if (taskLower.includes('component')) {
      files.push('src/components/[Feature].tsx');
    }
    if (taskLower.includes('service')) {
      files.push('src/services/[feature].service.ts');
    }
    if (taskLower.includes('model') || taskLower.includes('schema')) {
      files.push('prisma/schema.prisma');
    }

    if (files.length === 0) {
      files.push('src/[feature].ts');
    }

    files.push('tests/[feature].test.ts');

    return files.join(', ');
  }

  /**
   * Generate implementation steps
   */
  generateImplementationSteps(taskName) {
    return `1. Create required files\n` +
           `2. Implement ${taskName} following project patterns\n` +
           `3. Add error handling\n` +
           `4. Write unit tests\n` +
           `5. Verify integration with completed features`;
  }

  /**
   * Generate verification commands
   */
  generateVerificationCommands(taskName) {
    return '```bash\n' +
           '# Verify file exists\n' +
           'test -f [new-file] && echo "✓ File created"\n\n' +
           '# Run tests\n' +
           'npm test -- [feature].test\n\n' +
           '# Verify no regression\n' +
           'npm test\n' +
           '```';
  }

  /**
   * Generate acceptance criteria
   */
  generateAcceptanceCriteria(taskName) {
    return `- ${taskName} implemented and working\n` +
           '- Tests pass for new feature\n' +
           '- Integration with existing code verified\n' +
           '- No regression on completed features';
  }

  /**
   * Generate standard fix wave (for bugs)
   */
  generateStandardFixWave() {
    return '## Wave Fix-1: Apply Fix\n\n' +
           '**Size:** SMALL\n' +
           '**Risk:** LOW\n\n' +
           '### Tasks\n\n' +
           '<task type="auto">\n' +
           '<name>Apply fix</name>\n' +
           '<files>See analysis</files>\n' +
           '<action>\n' +
           'Apply the recommended solution.\n' +
           '</action>\n' +
           '<verify>\n' +
           'npm test\n' +
           '</verify>\n' +
           '<done>\n' +
           'Issue resolved, tests pass\n' +
           '</done>\n' +
           '</task>';
  }

  /**
   * Generate success criteria
   */
  generateSuccessCriteria() {
    let criteria = '## Success Criteria\n\n';

    if (this.analysis.classification.type === 'incomplete-implementation') {
      const incompleteness = this.analysis.classification.incompleteness;
      
      criteria += '- ✅ All missing deliverables implemented\n';
      criteria += `- ✅ Feature completeness: 100% (${incompleteness.total}/${incompleteness.total} tasks)\n`;
      criteria += '- ✅ New features integrated with completed work\n';
      
      const completed = incompleteness.completedTasks || [];
      if (completed.length > 0) {
        const taskNums = completed.map(t => t.match(/Task (\d+)/)).filter(m => m).map(m => m[1]).join(', ');
        criteria += `- ✅ No impact on completed tasks (${taskNums})\n`;
      }
      
      criteria += '- ✅ All tests pass (new + existing)\n';
      criteria += '- ✅ Original plan verification now succeeds\n';
    } else {
      criteria += '- ✅ Issue resolved\n';
      criteria += '- ✅ Tests pass\n';
      criteria += '- ✅ No regressions\n';
    }

    return criteria;
  }

  /**
   * Generate verification section
   */
  generateVerification() {
    let verification = '## Verification\n\n';
    verification += '### Overall Checks\n\n';
    verification += '```bash\n';
    verification += '# Run full test suite\n';
    verification += 'npm test\n\n';

    if (this.analysis.classification.type === 'incomplete-implementation') {
      verification += '# Verify missing items now exist\n';
      const missing = this.analysis.classification.incompleteness.missing || [];
      missing.forEach(task => {
        const file = this.inferMainFile(task);
        verification += `test -f ${file} && echo "✓ ${task} exists"\n`;
      });
      verification += '\n';
      verification += '# Re-verify original plan\n';
      verification += `reis verify ${this.getOriginalPlanPath()}\n`;
      verification += '# Should now show 100% complete\n';
    }

    verification += '```\n\n';
    verification += '### Regression Checks\n\n';
    verification += '```bash\n';
    verification += '# Ensure existing features still work\n';
    verification += 'npm test\n';
    verification += '```';

    return verification;
  }

  /**
   * Generate notes section
   */
  generateNotes() {
    let notes = '## Notes\n\n';
    notes += '### Implementation Guidance\n\n';

    if (this.analysis.classification.type === 'incomplete-implementation') {
      const missing = this.analysis.classification.incompleteness.missing || [];
      notes += `Focus ONLY on the ${missing.length} missing feature(s).\n\n`;
      notes += 'Reference completed tasks for patterns and utilities.\n\n';
      notes += 'Do not refactor or optimize completed code.\n\n';
      notes += 'Keep changes isolated to new features.\n';
    } else {
      notes += 'Apply minimal changes to fix the issue.\n';
    }

    notes += '\n\n### References\n\n';
    notes += `- Original plan: ${this.getOriginalPlanPath()}\n`;
    notes += '- Debug report: .planning/debug/DEBUG_REPORT.md\n';

    return notes;
  }

  /**
   * Helper methods
   */
  getOriginalPlanPath() {
    // Try to extract from debug input
    return this.analysis.context?.originalPlan || '[original-plan.PLAN.md]';
  }

  inferMainFile(taskDescription) {
    const taskLower = taskDescription.toLowerCase();
    if (taskLower.includes('password')) return 'src/api/auth/reset-password.ts';
    if (taskLower.includes('endpoint')) return 'src/api/[feature].ts';
    return 'src/[feature].ts';
  }

  estimateWaveSize(taskCount) {
    if (taskCount === 1) return 'SMALL';
    if (taskCount <= 3) return 'MEDIUM';
    return 'LARGE';
  }

  estimateTime(taskCount) {
    const minutes = taskCount * 30;
    if (minutes < 60) return `${minutes} min`;
    return `${Math.round(minutes / 60)} hours`;
  }
}

/**
 * Generate and save FIX_PLAN.md
 */
export function generateFixPlan(analysis, outputPath = '.planning/debug/FIX_PLAN.md') {
  const generator = new FixPlanGenerator(analysis);
  const plan = generator.generate();

  // Ensure directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(outputPath, plan);
  
  return outputPath;
}
```

**What to avoid:**
- Generic fix plans (must be specific to issue type)
- Missing FR2.1 targeted scope for incomplete implementations
- Re-implementing completed features
- No DO NOT constraints for incomplete implementations

**Why:**
- Targeted fix plans prevent wasted re-implementation
- Clear constraints prevent scope creep
- Executable format enables automation
</action>
<verify>
```bash
# Check file exists
test -f lib/utils/fix-plan-generator.js && echo "✓ fix-plan-generator.js created"

# Verify FR2.1 incomplete implementation support
grep -c "incomplete-implementation" lib/utils/fix-plan-generator.js
# Should find 15+ occurrences

# Check for DO NOT constraints
grep -q "DO NOT" lib/utils/fix-plan-generator.js && echo "✓ Constraints included"

# Test syntax
node -c lib/utils/fix-plan-generator.js && echo "✓ Syntax valid"
```
</verify>
<done>
- lib/utils/fix-plan-generator.js created with full implementation
- FR2.1 targeted fix plan generation for incomplete implementations
- Generates executable PLAN.md format
- Includes DO NOT constraints to prevent re-implementation
- Completeness analysis in context section
- Specific tasks for each missing feature
- Integration and verification sections
- Success criteria with 100% completion target
</done>
</task>

## Success Criteria
- ✅ FixPlanGenerator creates executable FIX_PLAN.md files
- ✅ FR2.1 targeted fix plans for incomplete implementations
- ✅ Plans follow PLAN.md format exactly
- ✅ Clear DO NOT constraints prevent re-implementation
- ✅ Plans are directly executable with reis execute-plan

## Verification
```bash
# Module exists
test -f lib/utils/fix-plan-generator.js && echo "✓ FixPlanGenerator implemented"

# Has FR2.1 support
grep -c "incomplete-implementation" lib/utils/fix-plan-generator.js
# Should find 15+ occurrences

# Syntax valid
node -c lib/utils/fix-plan-generator.js && echo "✓ Valid JavaScript"
```
